
# Java 集合 

![](https://file1.kamacoder.com/i/bagu/_Javarongqisiweidaotu_posper.png)

Sting 导图

![](https://file1.kamacoder.com/i/bagu/_StringTable_posper.png)


List导图 

![](https://file1.kamacoder.com/i/bagu/_Java_List_sufeng.png)
## ArrayList 和 Array 有什么区别？ArrayList 和 LinkedList 的区别是什么？（考点：底层数据结构、性能差异）【简单】

### ArrayList 和 Array 的区别：

1. **类型**：
	- `Array` 是Java中的一个基本数据结构，可以存储基本类型数据或对象引用。
	- `ArrayList` 是Java集合框架中的一个类，实现了`List`接口，只能存储对象引用。
2. **大小可变性**：
	- `Array` 的大小在创建时确定，一旦创建就无法改变。
	- `ArrayList` 的大小是动态的，可以根据需要自动扩容。
3. **性能**：
	- 访问元素时，`Array` 通常比 `ArrayList` 快，因为 `Array` 直接通过索引访问。
	- `ArrayList` 在添加或删除元素时可能更高效，尤其是在数组末尾操作时。
4. **泛型支持**：
	- `Array` 可以是泛型的，也可以不是。
	- `ArrayList` 必须是泛型的，提供了类型安全。
5. **方法**：
	- `Array` 提供的操作比较有限，主要是基本的数据访问和修改。
	- `ArrayList` 提供了更多的方法，如添加、删除、迭代等。

### ArrayList 和 LinkedList 的区别：

1. **数据结构**：
	- `ArrayList` 是基于动态数组实现的，适合随机访问。
	- `LinkedList` 是基于双向链表实现的，适合插入和删除操作。
2. **性能**：
	- `ArrayList` 在随机访问元素时更快，因为它是通过索引直接访问。
	- `LinkedList` 在插入和删除元素时更快，因为它不需要移动其他元素。
3. **内存占用**：
	- `ArrayList` 由于是基于数组，它在存储大量元素时可能会更高效。
	- `LinkedList` 每个元素都需要额外的内存空间来存储前驱和后继元素的引用。
4. **扩容**：
	- `ArrayList` 在元素数量达到容量时需要扩容，这个过程涉及到创建新数组和复制旧数组元素。
	- `LinkedList` 不需要扩容，因为它通过链接节点来增加元素。
5. **功能**：
	- `ArrayList` 提供了更快的随机访问和更高效的内存使用。
	- `LinkedList` 提供了更高效的插入和删除操作，并且可以更有效地实现栈和队列等数据结构。

在选择`ArrayList`还是`LinkedList`时，应该根据具体的应用场景和性能需求来决定。如果频繁进行随机访问操作，`ArrayList`是更好的选择；如果频繁进行插入和删除操作，`LinkedList`可能更合适。

## HashSet是如何保证元素不重复的？（考点：哈希算法、equals和hashCode方法）【简单】

**HashSet** 是Java集合框架中的一个实现了 `Set` 接口的类，用于存储不允许重复的元素。HashSet通过以下机制来确保元素的唯一性：
1. **基于哈希表实现**：
	- HashSet内部实际上是通过一个 `HashMap` 来存储元素。每个存储在HashSet中的元素作为HashMap的键（key），对应的值（value）是一个固定的常量对象（通常是一个私有的 `PRESENT` 对象）。
2. **使用`hashCode()`和`equals()`方法**：
	- **`hashCode()`方法**：当向HashSet添加一个元素时，首先调用该元素的 `hashCode()` 方法来计算其哈希值。这个哈希值决定了元素在哈希表中的存储位置（即桶的位置）。
	- **`equals()`方法**：在确定元素存储位置后，HashSet会检查该位置是否已经存在一个具有相同哈希值的元素。如果存在，会调用该元素的 `equals()` 方法来判断两个元素是否相等。如果两个元素相等，则认为该元素已经存在，添加操作失败；否则，元素被添加到哈希表中。
3. **避免重复**：
	- 通过上述的 `hashCode()` 和 `equals()` 方法，HashSet可以快速检测和防止重复元素的添加，确保每个元素在Set中是唯一的。

## List接口和Set接口的区别是什么？（考点：接口特性、集合类型）【简单】

- 1、是否允许元素重复
- 2、是否保证元素的插入顺序
- 3、元素位置访问：
	- List提供了按照索引访问元素的方法，如：get（），Set没有提供这样的方法
	

## Java中的HashMap了解吗？HashMap 的底层实现是什么?（考点：底层数据结构）【简单】

HashMap存储数据采用了哈希表的结构，底层使用 一维数组+单向链表+红黑树 进行key-value数据的存储

- 红黑树出现的时机：当某个索引位置i上的链表的长度达到8，且数组的长度超过64时，此索引位置上的元素要从单向链表改为红黑树。--->原因：红黑树进行put()/get()/remove()操作的时间复杂度时o(logn)，比单向链表的时间复杂度o(n)好。
- 红黑树退化成单向链表：如果索引i位置是红黑树的结构，当不断删除元素的情况下，当前索引i位置上的元素的个数低于6时，要从红黑树改为单向链表。

![image.png](http://cdn.notes.kamacoder.com/9cca7bdf-b107-41a5-bef2-7dfd011e6f11.png)

## HashMap 的扩容机制是怎样的？（考点：数组复制、内存分配）【简单】

简单来说，`HashMap` 的扩容机制是这样的：

1. **触发条件：** 当 `HashMap` 中存储的键值对数量（`size`）超过了一个**阈值**时，就会触发扩容。这个阈值通常是 `当前容量 * 加载因子（loadFactor，默认0.75）`。

2. **扩容过程：**
	- **创建新数组：** 创建一个**新的、更大的数组**，通常是原数组容量的**两倍**。
	- **重新计算哈希与迁移 (Rehashing)：** 遍历旧数组中的**每一个**键值对，**重新计算**它们在新数组中的位置（因为数组长度变了，哈希映射的索引也会变），然后将它们放入新数组的对应位置。这个过程很重要，因为同一个元素在新旧数组中的桶（bucket）索引很可能不同。

3. **目的：**
	- **减少哈希冲突：** 通过扩大数组容量，使得键值对能更均匀地分布，从而减少哈希冲突，保持 `HashMap` 的查找、插入等操作的效率（接近 O(1)）。
	- **保持性能：** 如果不扩容，当元素越来越多时，链表（或红黑树）会越来越长，性能会下降。


简单讲就是：**装不下了（或快装不下了，为了性能） -> 造个更大的新家 -> 把旧家里的东西重新摆放到新家里。**

## TreeMap和HashMap的区别是什么？（考点：底层数据结构、排序特性）【简单】

- 实现原理：
	- HashMap基于hash表实现，计算键的hash值来确定存储位置。默认情况下，hashmap不保证元素的存储顺序，从java8之后，h链表过长会转化为红黑树
	- TreeMap基于红黑树实现，是一种自平衡二叉查找树，能够保持键的有序性，因此，TreeMap中的元素总是按照键的自然顺序或者创建时提供的Comparator进行排序。
- 性能特点：
	- HashMap查找、插入、删除的平均复杂度均为O（1）
	- TreeMap查找、插入、删除的时间复杂度均为O（logn）

## HashSet 和 HashMap 的区别？（考点：底层数据结构）【简单】
1. **存储内容不同：**
	- `HashSet`：存储的是**不重复的单个元素**（对象）。它主要用来快速检查某个元素是否存在于集合中。
	- `HashMap`：存储的是**键值对 (Key-Value pairs)**。它用来根据键快速查找对应的值。

2. **内部实现关系：**
	- `HashSet` **内部实际上是基于 `HashMap` 实现的**。当你向 `HashSet` 添加一个元素时，这个元素会作为 `HashMap` 的键 (Key)，而对应的值 (Value) 则是一个固定的虚拟对象 (dummy Object)。


简单说：

- `HashSet` 就像一个只有“物品清单”的集合，只关心物品本身在不在。

- `HashMap` 像一个“字典”或“名册”，每个“词条”（键）都有对应的“解释”（值）。


所以，如果你只需要存储一堆不重复的东西，用 `HashSet`；如果你需要给这些东西关联额外的信息，用 `HashMap`。

## HashMap 和 HashTable 的区别？（考点：底层数据结构）【简单】
简要回答 `HashMap` 和 `Hashtable` 的主要区别：

1. **线程安全性：**
	- `HashMap`：**非线程安全**。
	- `Hashtable`：**线程安全**。它的方法大多是 `synchronized` 的，并发性能较低。

2. **null 键和 null 值：**
	- `HashMap`：**允许**一个 `null` 键和多个 `null` 值。
	- `Hashtable`：**不允许** `null` 键，也**不允许** `null` 值（会抛出 `NullPointerException`）。

3. **性能：**
	- `HashMap`：由于非线程安全，单线程下性能通常比 `Hashtable` 好。
	- `Hashtable`：由于方法同步，多线程开销较大，性能通常较低。在需要线程安全的场景下，更推荐使用 `ConcurrentHashMap`。

4. **父类：**
	- `HashMap`：继承自 `AbstractMap` 类。
	- `Hashtable`：继承自 `Dictionary` 类（一个比较老的类）。


**总结：** `Hashtable` 是一个遗留的线程安全类，性能较差。如果需要线程安全，**推荐使用 `ConcurrentHashMap`**。如果不需要线程安全，**使用 `HashMap`**。

## Java的集合类有哪些，那些是线程安全的，那些是线程不安全的？（考点：线程安全）【简单】

#### Java的集合类

>Java的集合主要是由Map和Collection这两个接口派生出来的。Collection接口又派生出三个重要的接口Set, List， Queue。

Java所有的集合类，都是Set, List，Map, Queue这几个接口的实现类。
- Set接口：Set接口的主要实现类有：HashSet, TreeSet, LinkedHashSet。Set集合最大的特征就是不允许存储重复的元素。
- List接口：List接口的主要实现类有：ArrayList, LinkedList。List接口里面存储的元素是有序的，并且允许存放重复的元素。
- Map接口: Map接口的主要实现类有：HashMap，TreeMap, LinkedHashMap。Map接口存放的就是键值对。
- Queue接口: Queue接口的主要实现类有：ArrayDeque, PriorityQueue。Queue接口主要是用来实现队列的。

#### 线程安全集合类

- Vector:这个和ArrayList类比较像，只不过Vector中的每个方法都被synchronized关键字修饰，所以Vector集合是线程安全的。
- HashTable:这个和HashMap类比较像，同样的HashTable中的每个方法都被synchronized关键字修饰。

java.util.concurrent 包提供的都是线程安全的集合：
- ConcurrentHashMap: ConcurrentHashMap通过锁分离技术实现了线程安全。

#### 线程不安全集合类

ArrayList，LinkedList， HashSet，HashMap，TreeSet，TreeMap 这些类都是线程不安全的集合类，只能在单线程环境下使用，在多线程环境下，如果没有合适的同步措施，就会造成数据不一致等并发问题。


##  ArrayList和普通数组的区别是什么？ 
### ArrayList 和 普通数组 的概念
1. **普通数组（Array）**：
    - **定义**：它是 Java 语言中一个内置的、**固定大小**的数据结构，用于存储一系列**相同类型**的元素。
	- **优点**：**访问速度快**（通过索引/下标直接访问元素），可以存储基本数据类型，内存开销小。
	- **缺点**：数组长度固定**不可变**，**增删元素不方便**，功能单一。
	- **适用场景**：元素数量已知且固定，对性能要求比较高，或仅需存储基本数据类型。
2. **`ArrayList`** ：
    - **定义**：它是 `java.util` 包下的一个集合类，是 `List` 接口的最常用的实现类，ArrayList 的底层是基于**动态数组**实现的。
	- **优点**：长度可变（动态扩容），具有丰富的API操作，且支持泛型。
	- **缺点**：**增删元素（特别是中间位置）效率相对较低**，存储基本类型时 存在装箱拆箱带来的开销。
	- **适用场景**：元素数量不确定，需要频繁查询或在末尾增删，需要集合框架提供的API操作。
### ArrayList 和 普通数组 的区别
- 如下表所示：

    | 维度 | 普通数组（Array） | `ArrayList` |
    | ------ | ------ | ------ |
    | **长度/容量** | **固定长度**，一旦创建，长度不可变。 | **长度可变**，可根据需要自动扩容和缩容。 |
    | **元素类型** | 可存储**基本数据类型**和**引用类型**，但不能混用。 | 只能存储**引用类型**（基本类型会自动装箱）。 |
    | **API/操作** | 功能单一，通过 `[]` 运算符访问，无内置方法。 | 提供了丰富的 API 方法（`add()`, `remove()`, `get()` 等）。 |
    | **泛型支持** | 不直接支持泛型，编译时类型检查不如 `ArrayList` 严格。 | **原生支持泛型**，提供编译时类型安全。 |
    | **底层实现** | 语言内置的底层数据结构。 | 基于**动态数组**实现，是集合框架的一部分。 |
***
## 详细回答
### ArrayList 和 普通数组 的概念
1. **普通数组（Array）**：
	- **定义**：数组是 Java 语言内置的一种最基本、最底层的数据结构。它的本质是一个**固定大小**的同类型元素的集合，数组的长度在创建时就已经确定，并且在程序运行过程中不可更改。
	- **优点**：
        ① **访问速度快**：因为数组在内存中是**连续存储**的，所以我们可以直接通过 **索引/下标** 直接计算出元素的内存地址，实现 **O(1)** 时间复杂度的 **随机访问**。
		② **内存开销小**：数组可以直接存储 `int`, `char`, `boolean` 等基本数据类型，避免了拆装箱带来的开销。
	- **缺点**：
        ① **数组一旦被创建，长度就无法改变**。如果需要增加或减少元素，必须创建一个新数组并将旧数组的元素复制过去，效率较低。
		② **增删元素不便**：在数组**中间位置插入或删除元素**需要移动大量后续元素，时间复杂度是 **O(n)** 。
	- **适用场景**：
        ① 当**元素数量已知且固定**时；
		② 对**性能要求极高**，且主要进行随机访问操作的场景；
		③ 需要存储**多维数据**（比如说矩阵）时。
2. **`ArrayList`** ：
	- **定义**：`ArrayList` 是 `java.util` 包中的一个集合类，底层是基于一个**动态数组**来实现的。它允许存储重复元素，并保持了元素的插入顺序。
	- **优点**：
        ① **长度可变（根据实际存储情况动态扩容）**：当元素数量超过当前容量时，它会自动扩容（通常是当前容量的 1.5 倍）。
		② 作为 Java 集合框架的一部分，`ArrayList` 提供了比方说是 `add()`, `remove()`, `get()`, `size()`, `contains()` 这些很方便操作元素的方法。
		③ **原生支持泛型**：`ArrayList<E>` 原生支持泛型，**在编译时进行类型检查**，提供了类型安全，避免了运行时 `ClassCastException`。
	- **缺点**：
		① **存储基本类型时有装箱拆箱带来的开销**：因为 `ArrayList` 只能存储引用类型。如果存储 `int` 等基本数据类型，Java 会自动进行**装箱（Autoboxing）**转换为 `Integer` 等包装类，带来了额外的内存开销。
		② **扩容带来的开销**：扩容操作本身（创建新数组和复制元素）也是有性能开销的。
	- **适用场景**：
        ① 当需要存储的**元素数量不确定**时。
		② 当需要利用 Java 集合框架提供的 **丰富功能** 和 **类型安全** 时。
### ArrayList 和 普通数组 的区别
1. **长度/容量**：
	- **普通数组**：具有**固定长度**，一旦数组被创建，数组的大小就无法更改。如果需要一个更大或更小的数组，就必须创建一个新数组，并将旧数组中的元素复制到新数组中。
	- **`ArrayList`**：具有**动态可变长度**。它是一个可变大小的集合，当集合内的元素数量达到了内部数组的当前容量，并需要添加新元素时，`ArrayList` 会自动创建一个更大的新数组，并将所有现有元素复制到新数组中（通常是当前容量的 1.5 倍），然后丢弃旧数组。
2. **元素类型**：
	- **普通数组**：可以直接存储**基本数据类型**（如 `int`, `char`, `boolean`等），也可以直接存储 **引用类型**（如 `String`, `Object`等）。但是不能混用，即一旦数组被声明为某种类型，它就只能存储该类型或其子类型的元素。
	- **`ArrayList`**：只能存储**引用类型**，存储基本数据类型会自动执行**装箱（Autoboxing）** 操作，将其转换为对应的包装类（例如，`int` 会被转换为 `Integer` 对象）。
3. **API/操作**：
	- **普通数组**：功能相对单一，主要通过 **`[]` 运算符** 来进行元素的存取，并没有内置的方法来执行常见的集合操作，如添加、删除、查找元素、获取当前大小等，这些操作需要我们手动实现。
	- **`ArrayList`**：作为 Java 集合框架的一部分，内部封装了很多实用的 **API 方法**。例如，`add()` 用于添加元素，`remove()` 用于删除元素，`get()` 用于获取元素，`size()` 用于获取当前元素数量，`contains()` 用于判断元素是否存在等。
4. **泛型支持**：
	- **普通数组**：泛型支持不如 `ArrayList` 严格。虽然我们可以去声明 `Object[]` 类型的数组来存储不同类型的对象，但它在编译时不会提供严格的类型检查，这可能会导致**运行时**出现 `ArrayStoreException`。例如，`String[]` 可以赋值给 `Object[]`（数组是**协变**的），但向 `Object[]` 中添加 `Integer` 会在运行时报错。
	- **`ArrayList`**：**原生支持泛型**（例如 `ArrayList<String>`）。这意味着在编译时，编译器会强制检查 要添加或获取的元素，它的类型是否与泛型参数一致，保证了**编译时类型安全**，避免了运行时出现 `ClassCastException`。
5. **底层实现**：
	- **普通数组**：是 Java 语言内置的**底层数据结构**。
	- **`ArrayList`**：是 Java 集合框架中的一个**集合类**，其底层是基于**普通数组**来实现的。`ArrayList` 内部维护一个 `Object[]` 数组elementData，并在此基础上封装了动态扩容、增删改查一套逻辑。
***
## 知识拓展
1. **ArrayList 和 普通数组 的区别**示意图如下：
    ![image](https://file1.kamacoder.com/i/bagu/Collection_ArrayList_vs_array.jpg)

2. **面试官可能的追问1：在 Java 中，当需要存储大量基本数据类型时，除了数组，还有其他什么选择吗？**
	- **Apache Commons Lang 库**：这个库提供了 `ArrayUtils` 等工具类，以及 `PrimitiveIterator` 等，可以更方便地操作基本类型数组。
	- **Guava 库**：提供了 `Ints`, `Longs` 等工具类，以及 `ImmutableList` 的基本类型版本，用于处理基本类型的集合，避免装箱。
	- **FastUtil 或 Trove 库**：这些是专门为高性能基本类型集合设计的第三方库，它们提供了 `IntArrayList`, `LongHashSet` 等，直接在内部使用基本类型数组，完全避免了装箱拆箱，性能远超 `java.util` 包中的标准集合类，适用于大数据量和对性能要求比较高的场景。
---


## HashMap 为什么是线程不安全的? 如何实现线程安全？（考点：线程安全、底层数据结构）【中等】

- HashMap是不安全的，主要是因为HashMap内部在多线程并发访问的时候，没有进行同步处理，所以在是线程不安全的
- 实现HashMap的线程安全有以下几种方法：
	- 调用Collections.syncronizedMap()方法来实现线程安全，会对所有方法调用加锁，确保同一时刻只有一个线程能够访问集合对象
	- 使用线程安全的集合类，如ConcurrentHashMap类，就是线程安全的

## Collection接口和Collections类的区别是什么？（考点：接口与类的区别、工具类作用）【简单】

- collection是一个接口，是java集合框架的根接口之一

- collections是一个工具类，包含了很多操作集合的静态方法

## Vector和ArrayList的区别是什么？（考点：线程安全、性能差异）【简单】
- 线程安全性：
	- Vector是线程安全的，他的每个方法都被声明为synchronized，多线程环境下可以直接使用不需要额外开销
	- ArrayList不是线程安全的
- 性能：
	- Vector由于所有公开的方法都是同步的，所以性能可能不如ArrayList
- 扩容机制：
	- Vector容量不足的情况下，会扩容至两倍
	- ArrayList容量不足的情况下，通常会扩容1.5倍


## HashMap在JDK1.8中有哪些改动？（考点：Java版本更新的影响）【中等】

1. 引入红黑树（TreeBin）

- **JDK 1.7 之前**：哈希冲突时采用 **拉链法**（链表存储），在链表过长时查询效率退化为 **O(n)**。
- **JDK 1.8**：当单个桶内元素过多（默认阈值 **8**）时，链表会转化为 **红黑树**，查找效率提升为 **O(log n)**。
  - 当元素减少到 **6** 以下时，会退回链表，避免频繁树化的性能损耗。
  - 这样能显著提升在高碰撞场景下的性能。

---

2. 数组 + 链表/红黑树的混合结构

- JDK 1.7：数组 + 链表。
- JDK 1.8：数组 + 链表 + 红黑树，存储结构更加灵活。

---

3. 使用 **尾插法** 替代头插法

- **JDK 1.7**：插入时用 **头插法**，可能导致链表反转，在多线程环境下容易出现环形链表 → 死循环。
- **JDK 1.8**：改为 **尾插法**，保持元素插入顺序，避免了并发问题。

---

4. 扩容机制优化

- **JDK 1.7**：扩容时需要 **重新计算所有元素的哈希值**。
- **JDK 1.8**：利用 **高位运算**（元素要么在原索引，要么移动到原索引 + oldCap），只需判断一个二进制位即可，减少了计算开销。

---

5. hash 函数优化

- **JDK 1.7**：直接用 key 的 `hashCode()` 高位参与运算。
- **JDK 1.8**：引入 `扰动函数 (hash >>> 16) ^ hash`，减少哈希冲突，分布更均匀。

---

总结（面试速答）

JDK 1.8 中 HashMap 主要的优化是：**引入红黑树优化链表查询效率、采用尾插法避免并发问题、扩容机制更高效、hash 函数优化，整体性能和稳定性更好。**
